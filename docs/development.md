# 開発概論

# 構成
+ [原理・原則](#原理・原則)
+ [パターン](#パターン)
+ [実践](#実践)
+ [参照](#参照)

## 原理・原則
### UNIX哲学
#### 基本定理
1. スモール・イズ・ビューティフル
1. 一つのプログラムには一つのことをうまくやらせる
1. できるだけ早く試作する
1. 効率より移植性
1. 数値データはASCIIフラットファイルに保存する
1. ソフトウェアの梃子を有効に活用する
1. シェルスクリプトを使うことで梃子の効果と移植性を高める
1. 過度の対話的インタフェースを避ける
1. すべてのプログラムをフィルタにする
#### さらなる10のUNIXの考え方
1. 好みに応じて自分で環境を調整できるようにする
1. オペレーティングシステムのカーネルを小さくする
1. 小文字を使い、短く
1. 木を守る
1. 沈黙は金
1. 並行して考える
1. 部分の総和は全体よりも大きい
1. 90パーセントの解を目指す
1. 劣るほうが優れている
1. 階層的に考える

### アジャイルの目的
>Deliver Something of Value Every Week  
>(価値ある成果を毎週届ける)  
>『アジャイルサムライ』  
>The professional goal of every software developer and every development team is to deliver the highest possible value to employers and customers  
>(プロの開発者のゴールは、可能な限り高品質の製品を雇い主や顧客に納品することである。)  
>『アジャイルソフトウエア開発の奥義』

### アジャイルアライアンス
#### ４の価値
+ プロセスやツールよりも個人と対話を
+ 包括的なドキュメントよりも動くソフトウェアを
+ 契約交渉よりも顧客との協調を
+ 計画に従うことよりも変化への対応を、

#### １２の原則
+ 顧客満足を最優先し、価値のあるソフトウェアを早く継続的に提供します。
+ 要求の変更はたとえ開発の後期であっても歓迎します。変化を味方につけることによって、お客様の競争力を引き上げます。
+ 動くソフトウェアを、2-3週間から2-3ヶ月というできるだけ短い時間間隔でリリースします。
+ ビジネス側の人と開発者は、プロジェクトを通して日々一緒に働かなければなりません。
+ 意欲に満ちた人々を集めてプロジェクトを構成します。環境と支援を与え仕事が無事終わるまで彼らを信頼します。
+ 情報を伝えるもっとも効率的で効果的な方法はフェイス・トゥ・フェイスで話をすることです。
+ 動くソフトウェアこそが進捗の最も重要な尺度です。
+ アジャイル･プロセスは持続可能な開発を促進します。一定のペースを継続的に維持できるようにしなければなりません。
+ 技術的卓越性と優れた設計に対する不断の注意が機敏さを高めます。
+ シンプルさ（ムダなく作れる量を最大限にすること）が本質です。
+ 最良のアーキテクチャ・要求・設計は、自己組織的なチームから生み出されます。
+ チームがもっと効率を高めることができるかを定期的に振り返り、それに基づいて自分たちのやり方を最適に調整します。

### アジャイルウェイ
>The “agile way”(「アジャイルの道」)  
>・Are we delivering something of value every week?  
>(毎週、価値ある成果を届けられているか？)  
>・Are we striving to continuously improve?  
>(たゆまぬ改善のための努力を惜しまず続けているか？)  
>If you can answer yes to both those questions,you’re being agile  
>(この２つの問いへの答えが「イエス」なら、君はアジャイルだ。)  
>『アジャイルサムライ』

### プログラミング
#### KISS (Keep It Simple, Stupid. or Keep It Short and Simple)
#### DRY (Don't Repeat Yourself.)
#### YAGNI (You Aren't Going to Need It.)
#### PIE (Program Intently and Expressively.)
#### SLAP(Single Level of Abstraction Principle.)
#### OCP (Open-Closed Principle.)
#### 名前重要 (Naming is important.)

### リファクタリング
#### リファクタリングの定義
#### リファクタリングを行う理由
+ リファクタリングはソフトウェア設計を改善する
+ リファクタリングはソフトウェアを理解しやすくする
+ リファクタリングはバグを見つけ出す
+ リファクタリングでより速くプログラミングできる
#### いつリファクタリングをすべきか
+ ３度目の法則
+ 機能追加時にリファクタリングを行う
+ バグフィックスの時にリファクタリングを行う
+ コードレビューの時にリファクタリングを行う
#### リファクタリングの問題点
+ データベース
+ インタフェースの変更
+ リファクタリングしにくい設計
+ リファクタリングを避ける時
#### リファクタリングと設計
#### リファクタリングとパフォーマンス

### 設計
+ 単一責任の原則(SRP)
+ オープン・クローズドの原則(OCP)
+ リスコフの置換原則(LSP)
+ 依存関係逆転の原則(DIP)
+ インタフェース分離の原則(ISP)

## パターン
### デザインパターン
#### 生成に関するパターン[編集]
+ Abstract Factory	関連する一連のインスタンスを状況に応じて、適切に生成する方法を提供する。
+ Builder	複合化されたインスタンスの生成過程を隠蔽する。
+ Factory Method	実際に生成されるインスタンスに依存しない、インスタンスの生成方法を提供する。
+ Prototype	同様のインスタンスを生成するために、原型のインスタンスを複製する。
+ Singleton あるクラスについて、インスタンスが単一であることを保証する。

#### 構造に関するパターン
+ Adapter	元々関連性のない2つのクラスを接続するクラスを作る。
+ Bridge	クラスなどの実装と、呼出し側の間の橋渡しをするクラスを用意し、実装を隠蔽する。
+ Composite	再帰的な構造を表現する。
+ Decorator	あるインスタンスに対し、動的に付加機能を追加する。Filterとも呼ばれる。
+ Facade	複数のサブシステムの窓口となる共通のインタフェースを提供する。
+ Flyweight	多数のインスタンスを共有し、インスタンスの構築のための負荷を減らす。
+ Proxy	共通のインタフェースを持つインスタンスを内包し、利用者からのアクセスを代理する。Wrapperとも呼ばれる

#### 振る舞いに関するパターン
+ Chain of Responsibility	イベントの送受信を行う複数のオブジェクトを鎖状につなぎ、それらの間をイベントが渡されてゆくようにする。
+ Command	複数の異なる操作について、それぞれに対応するオブジェクトを用意し、オブジェクトを切り替えることで、操作の切替えを実現する。
+ Interpreter	構文解析のために、文法規則を反映するクラス構造を作る。
+ Iterator	複数の要素を内包するオブジェクトのすべての要素に対して、順番にアクセスする方法を提供する。反復子。
+ Mediator	オブジェクト間の相互作用を仲介するオブジェクトを定義し、オブジェクト間の結合度を低くする。
+ Memento	データ構造に対する一連の操作のそれぞれを記録しておき、以前の状態の復帰または操作の再現が行えるようにする。
+ Observer (出版-購読型モデル)	インスタンスの変化を他のインスタンスから監視できるようにする。Listenerとも呼ばれる。
+ State	オブジェクトの状態を変化させることで、処理内容を変えられるようにする。
+ Strategy	データ構造に対して適用する一連のアルゴリズムをカプセル化し、アルゴリズムの切替えを容易にする。
+ Template Method	あるアルゴリズムの途中経過で必要な処理を抽象メソッドに委ね、その実装を変えることで処理が変えられるようにする。
+ Visitor	データ構造を保持するクラスと、それに対して処理を行うクラスを分離する。

#### マルチスレッドプログラミングに関するパターン
+ Active Object (Actor)	メソッドの呼び出しとメソッドの実際の実行を分離することで、並行性を導入する。各オブジェクトは、利用者からの要求を管理するためのメッセージキューとスケジューラを持つ。
+ Balking	前提条件が満たされていない場合は、(その時点での)処理の実行をあきらめる。
+ Double-checked locking	ロックの取得におけるオーバヘッドを削減するための技法。まずスレッドセーフでない方法で「ロックヒント」を調べて、それが成功したら実際のロックを試みる。
+ Future	「処理が完了しているかどうか分からない処理結果」を表すオブジェクトを作成することで同期を実現する。処理が完了していないうちに結果を取得しようとした場合は、処理が完了するまでロックされる。
+ Guarded suspension	前提条件が満たされるまで待機するための機構。
+ Lock	リソースに対して1つのスレッドが「ロック」をかけて、その間は他のスレッドがそのリソースにアクセスしたり変更を加えたりできないようにする。[2]
+ Monitor	排他的に実行しなければならないメソッド群を持つオブジェクトをスレッドセーフに利用できるようにするための機構。Javaは、これを言語レベルでサポートしている。
+ Producer-consumer	「生産者」 (producer) スレッド群がデータを生成して「通信路」に追加し、「消費者」 (consumer) スレッド群がそのデータを「通信路」から取り出して処理するという構造。必要な同期はすべて「通信路」によって行なわれるため、生産者と消費者のルーチンは同期を意識せずに実装できる。この通信路は、同期キューなどで実現される（一部の言語はこれを標準ライブラリで提供している）。
+ Reactor	同期的に扱わなければならないリソース群に対する非同期的インタフェースを提供する。
+ Readers-writer lock	書き込みは排他アクセスが必要だが、読み込みは並行に行えるようにしたい場合のためのロック機構。
+ Scheduler	シングルスレッドで実行される処理（例えばファイルへの書き込み）の実行を各スレッドに許可するタイミングを明確に制御する。
+ Thread pool	多数のスレッドを作成して、それらに多数のタスクを処理させる。典型的な状況では！スレッド数よりもかなり多くのタスクが存在し、各スレッドは、あるタスクの処理が終わると次の処理待ちタスクの実行に取りかかる。一般に、Producer-consumerパターンを使って実現される。
+ Thread-specific storage	静的変数・グローバル変数のように扱えるがスレッドごとに異なる内容を格納できるメモリ領域を提供する。
+ Two-phase termination	スレッドを安全に終了させる方法。スレッドは、終了要求を表すフラグを定期的に確認して、それがセットされたら終了処理を行う。

## リファクタリングカタログ
### メソッドの構成
### オブジェクト間での特性の移動
### データの再編成
### 条件記述の単純化
### メソッド呼び出しの単純化
### 継承の取り扱い

## 実践
## XP
### チームメンバーとしての顧客
### ユーザーストーリー
### 短期間のリリースサイクル
+ イテレーションプラン
+ リリースプライン
### 受け入れテスト
### ペアプログラミング
### テストファースト開発
### 共同所有権
### 継続的なインテグレーション（統合）
### 持続可能なペース
### オープンワークスペース
### 計画ゲーム
### シンプルな設計
### リファクタリング
### メタファー
## 設計
### 設計の悪臭
1. 硬さ
1. もろさ
1. 移植性のなさ
1. 扱いにくさ
1. 不必要な複雑さ
1. 不必要な繰り返し
1. 不透明さ

## リファクタリング
### コードの不吉な臭い
### メソッドの構成
### オブジェクト間での特性の移動
### データの再編成
### 条件記述の単純化
### メソッド呼び出しの単純化
### 継承の取り扱い


## 参照
+ [ドメイン層の設計ガイド](https://github.com/system-sekkei/isolating-the-domain/wiki/%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E5%B1%A4%E3%81%AE%E8%A8%AD%E8%A8%88%E3%82%AC%E3%82%A4%E3%83%89)
+ [ドメインオブジェクトの設計ガイド](https://github.com/system-sekkei/isolating-the-domain/wiki/%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E8%A8%AD%E8%A8%88%E3%82%AC%E3%82%A4%E3%83%89)
+ [ドメインオブジェクトの見つけ方・作り方・育て方](https://www.slideshare.net/masuda220/ss-62386442)
