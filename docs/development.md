# 開発概論

# 構成
+ [原理・原則](#原理・原則)
+ [パターン](#パターン)
+ [実践](#実践)
+ [参照](#参照)

## 原理・原則
### UNIX哲学
#### 基本定理
1. スモール・イズ・ビューティフル
1. 一つのプログラムには一つのことをうまくやらせる
1. できるだけ早く試作する
1. 効率より移植性
1. 数値データはASCIIフラットファイルに保存する
1. ソフトウェアの梃子を有効に活用する
1. シェルスクリプトを使うことで梃子の効果と移植性を高める
1. 過度の対話的インタフェースを避ける
1. すべてのプログラムをフィルタにする
#### さらなる10のUNIXの考え方
1. 好みに応じて自分で環境を調整できるようにする
1. オペレーティングシステムのカーネルを小さくする
1. 小文字を使い、短く
1. 木を守る
1. 沈黙は金
1. 並行して考える
1. 部分の総和は全体よりも大きい
1. 90パーセントの解を目指す
1. 劣るほうが優れている
1. 階層的に考える

### プログラミング
#### KISS (Keep It Simple, Stupid. or Keep It Short and Simple)
#### DRY (Don't Repeat Yourself.)
#### YAGNI (You Aren't Going to Need It.)
#### PIE (Program Intently and Expressively.)
#### SLAP(Single Level of Abstraction Principle.)
#### OCP (Open-Closed Principle.)
#### 名前重要 (Naming is important.)

### リファクタリング
#### リファクタリングの定義
#### リファクタリングを行う理由
+ リファクタリングはソフトウェア設計を改善する
+ リファクタリングはソフトウェアを理解しやすくする
+ リファクタリングはバグを見つけ出す
+ リファクタリングでより速くプログラミングできる
#### いつリファクタリングをすべきか
+ ３度目の法則
+ 機能追加時にリファクタリングを行う
+ バグフィックスの時にリファクタリングを行う
+ コードレビューの時にリファクタリングを行う
#### リファクタリングの問題点
+ データベース
+ インタフェースの変更
+ リファクタリングしにくい設計
+ リファクタリングを避ける時
#### リファクタリングと設計
#### リファクタリングとパフォーマンス

### 設計
+ 単一責任の原則(SRP)
+ オープン・クローズドの原則(OCP)
+ リスコフの置換原則(LSP)
+ 依存関係逆転の原則(DIP)
+ インタフェース分離の原則(ISP)

## パターン
### デザインパターン
#### 生成に関するパターン[編集]
+ Abstract Factory	関連する一連のインスタンスを状況に応じて、適切に生成する方法を提供する。
+ Builder	複合化されたインスタンスの生成過程を隠蔽する。
+ Factory Method	実際に生成されるインスタンスに依存しない、インスタンスの生成方法を提供する。
+ Prototype	同様のインスタンスを生成するために、原型のインスタンスを複製する。
+ Singleton あるクラスについて、インスタンスが単一であることを保証する。

#### 構造に関するパターン
+ Adapter	元々関連性のない2つのクラスを接続するクラスを作る。
+ Bridge	クラスなどの実装と、呼出し側の間の橋渡しをするクラスを用意し、実装を隠蔽する。
+ Composite	再帰的な構造を表現する。
+ Decorator	あるインスタンスに対し、動的に付加機能を追加する。Filterとも呼ばれる。
+ Facade	複数のサブシステムの窓口となる共通のインタフェースを提供する。
+ Flyweight	多数のインスタンスを共有し、インスタンスの構築のための負荷を減らす。
+ Proxy	共通のインタフェースを持つインスタンスを内包し、利用者からのアクセスを代理する。Wrapperとも呼ばれる

#### 振る舞いに関するパターン
+ Chain of Responsibility	イベントの送受信を行う複数のオブジェクトを鎖状につなぎ、それらの間をイベントが渡されてゆくようにする。
+ Command	複数の異なる操作について、それぞれに対応するオブジェクトを用意し、オブジェクトを切り替えることで、操作の切替えを実現する。
+ Interpreter	構文解析のために、文法規則を反映するクラス構造を作る。
+ Iterator	複数の要素を内包するオブジェクトのすべての要素に対して、順番にアクセスする方法を提供する。反復子。
+ Mediator	オブジェクト間の相互作用を仲介するオブジェクトを定義し、オブジェクト間の結合度を低くする。
+ Memento	データ構造に対する一連の操作のそれぞれを記録しておき、以前の状態の復帰または操作の再現が行えるようにする。
+ Observer (出版-購読型モデル)	インスタンスの変化を他のインスタンスから監視できるようにする。Listenerとも呼ばれる。
+ State	オブジェクトの状態を変化させることで、処理内容を変えられるようにする。
+ Strategy	データ構造に対して適用する一連のアルゴリズムをカプセル化し、アルゴリズムの切替えを容易にする。
+ Template Method	あるアルゴリズムの途中経過で必要な処理を抽象メソッドに委ね、その実装を変えることで処理が変えられるようにする。
+ Visitor	データ構造を保持するクラスと、それに対して処理を行うクラスを分離する。

#### マルチスレッドプログラミングに関するパターン
+ Active Object (Actor)	メソッドの呼び出しとメソッドの実際の実行を分離することで、並行性を導入する。各オブジェクトは、利用者からの要求を管理するためのメッセージキューとスケジューラを持つ。
+ Balking	前提条件が満たされていない場合は、(その時点での)処理の実行をあきらめる。
+ Double-checked locking	ロックの取得におけるオーバヘッドを削減するための技法。まずスレッドセーフでない方法で「ロックヒント」を調べて、それが成功したら実際のロックを試みる。
+ Future	「処理が完了しているかどうか分からない処理結果」を表すオブジェクトを作成することで同期を実現する。処理が完了していないうちに結果を取得しようとした場合は、処理が完了するまでロックされる。
+ Guarded suspension	前提条件が満たされるまで待機するための機構。
+ Lock	リソースに対して1つのスレッドが「ロック」をかけて、その間は他のスレッドがそのリソースにアクセスしたり変更を加えたりできないようにする。[2]
+ Monitor	排他的に実行しなければならないメソッド群を持つオブジェクトをスレッドセーフに利用できるようにするための機構。Javaは、これを言語レベルでサポートしている。
+ Producer-consumer	「生産者」 (producer) スレッド群がデータを生成して「通信路」に追加し、「消費者」 (consumer) スレッド群がそのデータを「通信路」から取り出して処理するという構造。必要な同期はすべて「通信路」によって行なわれるため、生産者と消費者のルーチンは同期を意識せずに実装できる。この通信路は、同期キューなどで実現される（一部の言語はこれを標準ライブラリで提供している）。
+ Reactor	同期的に扱わなければならないリソース群に対する非同期的インタフェースを提供する。
+ Readers-writer lock	書き込みは排他アクセスが必要だが、読み込みは並行に行えるようにしたい場合のためのロック機構。
+ Scheduler	シングルスレッドで実行される処理（例えばファイルへの書き込み）の実行を各スレッドに許可するタイミングを明確に制御する。
+ Thread pool	多数のスレッドを作成して、それらに多数のタスクを処理させる。典型的な状況では！スレッド数よりもかなり多くのタスクが存在し、各スレッドは、あるタスクの処理が終わると次の処理待ちタスクの実行に取りかかる。一般に、Producer-consumerパターンを使って実現される。
+ Thread-specific storage	静的変数・グローバル変数のように扱えるがスレッドごとに異なる内容を格納できるメモリ領域を提供する。
+ Two-phase termination	スレッドを安全に終了させる方法。スレッドは、終了要求を表すフラグを定期的に確認して、それがセットされたら終了処理を行う。

## 実践
## リファクタリング
### コードの不吉な臭い
### メソッドの構成
### オブジェクト間での特性の移動
### データの再編成
### 条件記述の単純化
### メソッド呼び出しの単純化
### 継承の取り扱い
## リファクタリングカタログ
### メソッドの構成
### オブジェクト間での特性の移動
### データの再編成
### 条件記述の単純化
### メソッド呼び出しの単純化
### 継承の取り扱い

## 参照
+ [ドメイン層の設計ガイド](https://github.com/system-sekkei/isolating-the-domain/wiki/%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E5%B1%A4%E3%81%AE%E8%A8%AD%E8%A8%88%E3%82%AC%E3%82%A4%E3%83%89)
+ [ドメインオブジェクトの設計ガイド](https://github.com/system-sekkei/isolating-the-domain/wiki/%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E8%A8%AD%E8%A8%88%E3%82%AC%E3%82%A4%E3%83%89)
+ [ドメインオブジェクトの見つけ方・作り方・育て方](https://www.slideshare.net/masuda220/ss-62386442)
